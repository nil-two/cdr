#!/bin/sh
set -eu

print_usage() {
  cat <<EOF
usage: ${0##*/} [<option(s)>] [<directory>]
chdir with recursive directory searching.

options:
  -b, --base=<directory>  use the directory to the base directory
  -f, --filter=<command>  use the command to select a directory
  -g, --git               enable searching from Git managed directories
  -G, --no-git            disable searching from Git managed directories
  -s, --source=<command>  use the command to list directories
  -w, --wrapper=<shell>   output the wrapper script for the shell and exit
      --help              print usage and exit
  [<directory>]           chdir to the directory without selecting

supported-shells:
  sh, bash

environment-variables:
  CDR_BASE    set default -b/--base (default: .)
  CDR_FILTER  set default -f/--filter (default: percol)
  CDR_GIT     set default -g/--git (default: false)
  CDR_SOURCE  set default -s/--source (default: find -type d)
EOF
}

print_wrapper_script() {
  case $1 in
    sh)
      cat <<'EOF'
cdr() {
  set -- "$(command cdr "$@")"
  if [ -d "$1" ]; then
    cd "$1" || return
  elif [ -n "$1" ]; then
    printf "%s\n" "$1"
  fi
}
EOF
      ;;
    bash)
      cat <<'EOF'
cdr() {
  set -- "$(command cdr "$@")"
  if [ -d "$1" ]; then
    cd "$1" || return
  elif [ -n "$1" ]; then
    printf "%s\n" "$1"
  fi
}

_cdr() {
  local cur prev words cword split
  _init_completion -s || return

  local options=(
    --base=
    --filter=
    --git
    --no-git
    --source=
    --wrapper=
    --help
  )
  local wrapper_target_shells=(
    sh
    bash
  )

  case $prev in
    -b|--base)
      _filedir -d
      return
      ;;
    -f|--filter)
      COMPREPLY=( $(compgen -A command -- "$cur") )
      return
      ;;
    -s|--source)
      COMPREPLY=( $(compgen -A command -- "$cur") )
      return
      ;;
    -w|--wrapper)
      COMPREPLY=( $(compgen -W '"${wrapper_target_shells[@]}"' -- "$cur") )
      return
      ;;
  esac
  $split && return

  case $cur in
    -*)
      COMPREPLY=( $(compgen -W '"${options[@]}"' -- "$cur") )
      [[ ${COMPREPLY[0]} == *= ]] && compopt -o nospace
      ;;
    *)
      _filedir -d
      ;;
  esac
}

complete -F _cdr cdr
EOF
      ;;
    *)
      printf "%s\n" "${0##*/}: unsupported shell -- '$1'" >&2
      return 1
      ;;
  esac
}

opt_base=${CDR_BASE:-}
opt_filter=${CDR_FILTER:-percol}
opt_git=${CDR_GIT:-false}
opt_source=${CDR_SOURCE:-find -type d}
opt_wrapper=
opt_help=false
arg_directory=
while [ $# -ge 1 ]; do
  case $1 in
    -b*|--base|--base=*)
      case $1 in
        -b|--base)
          if [ $# -lt 2 ]; then
            printf "%s\n" "${0##*/}: option requires an argument -- '${1##*-}'" >&2
            exit 1
          fi
          opt_base=$2
          shift
          ;;
        -b*)
          opt_base=${1#-b}
          ;;
        --base=*)
          opt_base=${1#--base=}
          ;;
      esac
      ;;
    -f*|--filter|--filter=*)
      case $1 in
        -f|--filter)
          if [ $# -lt 2 ]; then
            printf "%s\n" "${0##*/}: option requires an argument -- '${1##*-}'" >&2
            exit 1
          fi
          opt_filter=$2
          shift
          ;;
        -f*)
          opt_filter=${1#-f}
          ;;
        --filter=*)
          opt_filter=${1#--filter=}
          ;;
      esac
      ;;
    -g*|--git)
      case $1 in
        -g|--git)
          opt_git=true
          ;;
        -g*)
          opt_git=true
          next=-${1#-g}
          shift
          set -- "$next" "$@"
          continue
          ;;
      esac
      ;;
    -G*|--no-git)
      case $1 in
        -G|--no-git)
          opt_git=false
          ;;
        -G*)
          opt_git=false
          next=-${1#-G}
          shift
          set -- "$next" "$@"
          continue
          ;;
      esac
      ;;
    -s*|--source|--source=*)
      case $1 in
        -s|--source)
          if [ $# -lt 2 ]; then
            printf "%s\n" "${0##*/}: option requires an argument -- '${1##*-}'" >&2
            exit 1
          fi
          opt_source=$2
          shift
          ;;
        -s*)
          opt_source=${1#-s}
          ;;
        --source=*)
          opt_source=${1#--source=}
          ;;
      esac
      ;;
    -w*|--wrapper|--wrapper=*)
      case $1 in
        -w|--wrapper)
          if [ $# -lt 2 ]; then
            printf "%s\n" "${0##*/}: option requires an argument -- '${1##*-}'" >&2
            exit 1
          fi
          opt_wrapper=$2
          shift
          ;;
        -w*)
          opt_wrapper=${1#-w}
          ;;
        --wrapper=*)
          opt_wrapper=${1#--wrapper=}
          ;;
      esac
      case $opt_wrapper in
        sh|bash)
          ;;
        *)
          printf "%s\n" "${0##*/}: unsupported shell -- '$opt_wrapper'" >&2
          exit 1
          ;;
      esac
      ;;
    --help)
      opt_help=true
      ;;
    --)
      shift
      break
      ;;
    -*)
      printf "%s\n" "${0##*/}: unrecognized option -- '$1'" >&2
      exit 1
      ;;
    *)
      break
      ;;
  esac
  shift
done
shift $((OPTIND - 1))
if [ $# -ge 1 ]; then
  arg_directory=$1
fi

if [ "$opt_help" = true ]; then
  print_usage
  exit 0
fi
if [ -n "$opt_wrapper" ]; then
  print_wrapper_script "$opt_wrapper"
  exit 0
fi
if [ -n "$arg_directory" ]; then
  printf "%s\n" "$arg_directory"
  exit 0
fi

if [ "$opt_git" = true ]; then
  opt_base=$(git rev-parse --show-toplevel)
  opt_source='echo .; git ls-tree -rd --name-only --full-tree HEAD'
fi
if [ -n "$opt_base" ]; then
  cd "$opt_base"
fi

directory=$(sh -c "$opt_source" | sh -c "$opt_filter")
if [ -z "$directory" ]; then
  printf "%s\n" "$directory"
  exit 1
fi
if [ -n "$opt_base" ]; then
  if [ ! -d "$opt_base/$directory" ]; then
    printf "%s\n" "$directory"
    exit 1
  fi
  directory=$opt_base/$directory
else
  if [ ! -d "$directory" ]; then
    printf "%s\n" "$directory"
    exit 1
  fi
fi

printf "%s\n" "$directory"
