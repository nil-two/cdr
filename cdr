#!/bin/bash
set -eu

print_usage() {
  cat <<EOF
usage: ${0##*/} [<option(s)>]
chdir with recursive directory searching.

options:
  -f, --filter=COMMAND  use COMMAND to select a directory (default: CDR_FILTER)
  -g, --git             enable searching from Git managed directoies
  -G, --no-git          disable searching from Git managed directoies
  -r, --root=ROOT       set ROOT to the base directory (default: .)
  -s, --source=COMMAND  use COMMAND to list directories (default: CDR_SOURCE)
  -w, --wrapper=SHELL   output the wrapper script for SHELL and exit
      --help            print usage and exit

supported-shells:
  bash

environment-variables:
  CDR_FILTER  set default -f/--filter (default: percol)
  CDR_GIT     set default -g/--git (default: false)
  CDR_ROOT    set default -r/--root (default: .)
  CDR_SOURCE  set default -s/--source (default: find -type d)
EOF
}

print_wrapper_script() {
  case $1 in
    bash)
      cat <<EOF
cdr() {
  # dst:argparse:start
  local filter_command=\${CDR_FILTER-percol}
  local git=\${CDR_GIT-false}
  local root=\${CDR_ROOT-.}
  local source_command=\${CDR_SOURCE-find -type d}
  local wrapper_target_shell=
  local is_help=false
  while [[ \$# -ge 1 ]]; do
    case \$1 in
      -f*|--filter|--filter=*)
        case \$1 in
          -f|--filter)
            if [[ \$# -lt 2 ]]; then
              printf "%s\n" "\${0##*/}: option requires an argument -- '\${1##*-}'" >&2
              return 1
            fi
            filter_command=\$2
            shift
            ;;
          -f*)
            filter_command=\${1#-f}
            ;;
          --filter=*)
            filter_command=\${1#--filter=}
            ;;
        esac
        ;;
      -g*|--git)
        case \$1 in
          -g|--git)
            git=true
            ;;
          -g*)
            git=true
            next=-\${1#-g}
            shift
            set -- "\$next" "\$@"
            continue
            ;;
        esac
        ;;
      -G*|--no-git)
        case \$1 in
          -G|--no-git)
            git=false
            ;;
          -G*)
            git=false
            next=-\${1#-G}
            shift
            set -- "\$next" "\$@"
            continue
            ;;
        esac
        ;;
      -r*|--root|--root=*)
        case \$1 in
          -r|--root)
            if [[ \$# -lt 2 ]]; then
              printf "%r\n" "\${0##*/}: option requires an argument -- '\${1##*-}'" >&2
              return 1
            fi
            root=\$2
            shift
            ;;
          -r*)
            root=\${1#-r}
            ;;
          --root=*)
            root=\${1#--root=}
            ;;
        esac
        ;;
      -s*|--source|--source=*)
        case \$1 in
          -s|--source)
            if [[ \$# -lt 2 ]]; then
              printf "%s\n" "\${0##*/}: option requires an argument -- '\${1##*-}'" >&2
              return 1
            fi
            source_command=\$2
            shift
            ;;
          -s*)
            source_command=\${1#-s}
            ;;
          --source=*)
            source_command=\${1#--source=}
            ;;
        esac
        ;;
      -w*|--wrapper|--wrapper=*)
        case \$1 in
          -w|--wrapper)
            if [[ \$# -lt 2 ]]; then
              printf "%s\n" "\${0##*/}: option requires an argument -- '\${1##*-}'" >&2
              return 1
            fi
            wrapper_target_shell=\$2
            shift
            ;;
          -w*)
            wrapper_target_shell=\${1#-w}
            ;;
          --wrapper=*)
            wrapper_target_shell=\${1#--wrapper=}
            ;;
        esac
        case \$wrapper_target_shell in
          bash)
            ;;
          *)
            printf "%s\n" "\${0##*/}: unsupported shell '\$wrapper_target_shell'" >&2
            return 1
            ;;
        esac
        ;;
      --help)
        is_help=true
        ;;
      --)
        shift
        break
        ;;
      -*)
        printf "%s\n" "\${0##*/}: unrecognized option '\$1'" >&2
        return 1
        ;;
      *)
        break
        ;;
    esac
    shift
  done
  # dst:argparse:end

  if [[ \$is_help = true ]]; then
    command cdr --help
    return 0
  fi
  if [[ -n \$wrapper_target_shell ]]; then
    command cdr --wrapper "\$wrapper_target_shell"
    return 0
  fi
  if [[ \$git = true ]]; then
    root=\$(git rev-parse --show-toplevel)
    if [[ -z \$root ]]; then
      return 1
    fi
    source_command='echo .; git ls-tree -rd --name-only --full-tree HEAD'
  fi

  local directory=\$(bash -c "\$source_command" | bash -c "\$filter_command")
  if [[ -z \$directory ]]; then
    return 1
  fi

  cd "\$root/\$directory"
}
EOF
      ;;
    *)
      printf "%s\n" "${0##*/}: unsupported shell '$1'" >&2
      exit 1
      ;;
  esac
}

# src:argparse:start
filter_command=${CDR_FILTER-percol}
git=${CDR_GIT-false}
root=${CDR_ROOT-.}
source_command=${CDR_SOURCE-find -type d}
wrapper_target_shell=
is_help=false
while [[ $# -ge 1 ]]; do
  case $1 in
    -f*|--filter|--filter=*)
      case $1 in
        -f|--filter)
          if [[ $# -lt 2 ]]; then
            printf "%s\n" "${0##*/}: option requires an argument -- '${1##*-}'" >&2
            exit 1
          fi
          filter_command=$2
          shift
          ;;
        -f*)
          filter_command=${1#-f}
          ;;
        --filter=*)
          filter_command=${1#--filter=}
          ;;
      esac
      ;;
    -g*|--git)
      case $1 in
        -g|--git)
          git=true
          ;;
        -g*)
          git=true
          next=-${1#-g}
          shift
          set -- "$next" "$@"
          continue
          ;;
      esac
      ;;
    -G*|--no-git)
      case $1 in
        -G|--no-git)
          git=false
          ;;
        -G*)
          git=false
          next=-${1#-G}
          shift
          set -- "$next" "$@"
          continue
          ;;
      esac
      ;;
    -r*|--root|--root=*)
      case $1 in
        -r|--root)
          if [[ $# -lt 2 ]]; then
            printf "%r\n" "${0##*/}: option requires an argument -- '${1##*-}'" >&2
            exit 1
          fi
          root=$2
          shift
          ;;
        -r*)
          root=${1#-r}
          ;;
        --root=*)
          root=${1#--root=}
          ;;
      esac
      ;;
    -s*|--source|--source=*)
      case $1 in
        -s|--source)
          if [[ $# -lt 2 ]]; then
            printf "%s\n" "${0##*/}: option requires an argument -- '${1##*-}'" >&2
            exit 1
          fi
          source_command=$2
          shift
          ;;
        -s*)
          source_command=${1#-s}
          ;;
        --source=*)
          source_command=${1#--source=}
          ;;
      esac
      ;;
    -w*|--wrapper|--wrapper=*)
      case $1 in
        -w|--wrapper)
          if [[ $# -lt 2 ]]; then
            printf "%s\n" "${0##*/}: option requires an argument -- '${1##*-}'" >&2
            exit 1
          fi
          wrapper_target_shell=$2
          shift
          ;;
        -w*)
          wrapper_target_shell=${1#-w}
          ;;
        --wrapper=*)
          wrapper_target_shell=${1#--wrapper=}
          ;;
      esac
      case $wrapper_target_shell in
        bash)
          ;;
        *)
          printf "%s\n" "${0##*/}: unsupported shell '$wrapper_target_shell'" >&2
          exit 1
          ;;
      esac
      ;;
    --help)
      is_help=true
      ;;
    --)
      shift
      break
      ;;
    -*)
      printf "%s\n" "${0##*/}: unrecognized option '$1'" >&2
      exit 1
      ;;
    *)
      break
      ;;
  esac
  shift
done
# src:argparse:end

if [[ $is_help = true ]]; then
  print_usage
  exit 0
fi
if [[ -n $wrapper_target_shell ]]; then
  print_wrapper_script "$wrapper_target_shell"
  exit 0
fi

cat <<EOF >&2
${0##*/}: shell integration not enabled
Please add the following line to your rcfile.

command -v ${0##*/} > /dev/null && eval "\$(${0##*/} -w bash)"
EOF
exit 1
